{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import process from 'node:process';\n\ninterface ArgInfoType {\n  type: 'number' | 'string' | 'array' | 'boolean';\n}\n\ninterface ArgInfoParser {\n  parser: (input: string) => unknown;\n}\n\ninterface ArgInfoOptional {\n  optional?: boolean;\n}\n\ninterface ArgInfoDefault {\n  default?: unknown;\n}\n\ninterface ArgInfoChoices {\n  choices?: readonly unknown[];\n}\n\ntype ArgInfo = (ArgInfoType | ArgInfoParser) & ArgInfoOptional & ArgInfoDefault & ArgInfoChoices;\n\ninterface MappedArgType<Choice> {\n  string: Choice extends (infer U)[] ? U : string;\n  number: Choice extends (infer U)[] ? U : number;\n  boolean: boolean;\n  array: string[];\n}\n\ntype Mutable<T> = { -readonly [P in keyof T]: T[P] };\n\ntype GetArgTypeInner<T extends ArgInfo> = T extends ArgInfoParser\n  ? ReturnType<T['parser']>\n  : T extends ArgInfoType\n  ? MappedArgType<Mutable<T['choices']>>[T['type']]\n  : never;\n\ntype GetArgTypeOptional<T extends ArgInfo> = T extends ArgInfoDefault ? T['default'] : undefined;\n\ntype GetArgType<T extends ArgInfo> = T extends ArgInfoOptional\n  ? GetArgTypeInner<T> | GetArgTypeOptional<T>\n  : GetArgTypeInner<T>;\n\ntype ArgReturnType<T extends Record<string, ArgInfo>> = {\n  [K in keyof T]: GetArgType<T[K]>;\n};\n\nexport interface Options {\n  env?: Record<string, string> | NodeJS.ProcessEnv;\n}\n\nexport type Config = Record<string, ArgInfo>;\n\nexport function createEnv<T extends Config>(info: T, options?: Options): ArgReturnType<T> {\n  const env = options?.env ?? process.env;\n\n  const config: Record<string, unknown> = {};\n\n  for (const [key, argInfo] of Object.entries(info)) {\n    const value = env[key];\n\n    if (!value) {\n      if ('default' in argInfo) {\n        config[key] = argInfo.default;\n      } else if (!argInfo.optional) {\n        throw new Error(`Missing environment variable: ${key}`);\n      }\n\n      continue;\n    }\n\n    if ('parser' in argInfo) {\n      config[key] = argInfo.parser(value);\n\n      continue;\n    }\n\n    if (argInfo.choices && !argInfo.choices.includes(value)) {\n      throw new TypeError(`Invalid value for ${key} environment variable: ${value}`);\n    }\n\n    switch (argInfo.type) {\n      case 'string':\n        config[key] = value;\n        break;\n      case 'number':\n        config[key] = parseNumber(key, value);\n        break;\n      case 'boolean':\n        config[key] = value.toLowerCase() === 'true' || value === '1';\n        break;\n      case 'array':\n        config[key] = value.split(/, ?/gu);\n        break;\n    }\n  }\n\n  return config as ArgReturnType<T>;\n}\n\nfunction parseNumber(key: string, value: string): number {\n  const numberValue = Number(value);\n  if (Number.isNaN(numberValue)) {\n    throw new TypeError(`Invalid value for ${key} environment variable, should be number: ${value}`);\n  }\n  return numberValue;\n}\n"],"mappings":";AAAA,OAAO,aAAa;AAuDb,SAAS,UAA4B,MAAS,SAAqC;AACxF,QAAM,MAAM,SAAS,OAAO,QAAQ;AAEpC,QAAM,SAAkC,CAAC;AAEzC,aAAW,CAAC,KAAK,OAAO,KAAK,OAAO,QAAQ,IAAI,GAAG;AACjD,UAAM,QAAQ,IAAI;AAElB,QAAI,CAAC,OAAO;AACV,UAAI,aAAa,SAAS;AACxB,eAAO,OAAO,QAAQ;AAAA,MACxB,WAAW,CAAC,QAAQ,UAAU;AAC5B,cAAM,IAAI,MAAM,iCAAiC,KAAK;AAAA,MACxD;AAEA;AAAA,IACF;AAEA,QAAI,YAAY,SAAS;AACvB,aAAO,OAAO,QAAQ,OAAO,KAAK;AAElC;AAAA,IACF;AAEA,QAAI,QAAQ,WAAW,CAAC,QAAQ,QAAQ,SAAS,KAAK,GAAG;AACvD,YAAM,IAAI,UAAU,qBAAqB,6BAA6B,OAAO;AAAA,IAC/E;AAEA,YAAQ,QAAQ,MAAM;AAAA,MACpB,KAAK;AACH,eAAO,OAAO;AACd;AAAA,MACF,KAAK;AACH,eAAO,OAAO,YAAY,KAAK,KAAK;AACpC;AAAA,MACF,KAAK;AACH,eAAO,OAAO,MAAM,YAAY,MAAM,UAAU,UAAU;AAC1D;AAAA,MACF,KAAK;AACH,eAAO,OAAO,MAAM,MAAM,OAAO;AACjC;AAAA,IACJ;AAAA,EACF;AAEA,SAAO;AACT;AAEA,SAAS,YAAY,KAAa,OAAuB;AACvD,QAAM,cAAc,OAAO,KAAK;AAChC,MAAI,OAAO,MAAM,WAAW,GAAG;AAC7B,UAAM,IAAI,UAAU,qBAAqB,+CAA+C,OAAO;AAAA,EACjG;AACA,SAAO;AACT;","names":[]}