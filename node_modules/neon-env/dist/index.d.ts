interface ArgInfoType {
    type: 'number' | 'string' | 'array' | 'boolean';
}
interface ArgInfoParser {
    parser: (input: string) => unknown;
}
interface ArgInfoOptional {
    optional?: boolean;
}
interface ArgInfoDefault {
    default?: unknown;
}
interface ArgInfoChoices {
    choices?: readonly unknown[];
}
type ArgInfo = (ArgInfoType | ArgInfoParser) & ArgInfoOptional & ArgInfoDefault & ArgInfoChoices;
interface MappedArgType<Choice> {
    string: Choice extends (infer U)[] ? U : string;
    number: Choice extends (infer U)[] ? U : number;
    boolean: boolean;
    array: string[];
}
type Mutable<T> = {
    -readonly [P in keyof T]: T[P];
};
type GetArgTypeInner<T extends ArgInfo> = T extends ArgInfoParser ? ReturnType<T['parser']> : T extends ArgInfoType ? MappedArgType<Mutable<T['choices']>>[T['type']] : never;
type GetArgTypeOptional<T extends ArgInfo> = T extends ArgInfoDefault ? T['default'] : undefined;
type GetArgType<T extends ArgInfo> = T extends ArgInfoOptional ? GetArgTypeInner<T> | GetArgTypeOptional<T> : GetArgTypeInner<T>;
type ArgReturnType<T extends Record<string, ArgInfo>> = {
    [K in keyof T]: GetArgType<T[K]>;
};
interface Options {
    env?: Record<string, string> | NodeJS.ProcessEnv;
}
type Config = Record<string, ArgInfo>;
declare function createEnv<T extends Config>(info: T, options?: Options): ArgReturnType<T>;

export { Config, Options, createEnv };
