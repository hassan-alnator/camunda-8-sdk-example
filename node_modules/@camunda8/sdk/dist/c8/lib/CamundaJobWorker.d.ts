import TypedEmitter from 'typed-emitter';
import { LosslessDto } from '../../lib';
import { ActivateJobsRequest, IProcessVariables, JobCompletionInterfaceRest, MustReturnJobActionAcknowledgement } from '../../zeebe/types';
import { Ctor, RestJob } from './C8Dto';
import { Logger } from './C8Logger';
import { CamundaRestClient } from './CamundaRestClient';
type CamundaJobWorkerEvents = {
    pollError: (error: Error) => void;
    start: () => void;
    stop: () => void;
    poll: ({ currentlyActiveJobCount, maxJobsToActivate, worker, }: {
        currentlyActiveJobCount: number;
        maxJobsToActivate: number;
        worker: string;
    }) => void;
};
export interface CamundaJobWorkerConfig<VariablesDto extends LosslessDto, CustomHeadersDto extends LosslessDto> extends ActivateJobsRequest {
    inputVariableDto?: Ctor<VariablesDto>;
    customHeadersDto?: Ctor<CustomHeadersDto>;
    /** How often the worker will poll for new jobs. Defaults to 30s */
    pollIntervalMs?: number;
    jobHandler: (job: RestJob<VariablesDto, CustomHeadersDto> & JobCompletionInterfaceRest<IProcessVariables>, log: Logger) => MustReturnJobActionAcknowledgement;
    logger?: Logger;
    /** Default: true. Start the worker polling immediately. If set to `false`, call the worker's `start()` method to start polling for work. */
    autoStart?: boolean;
}
declare const CamundaJobWorker_base: new () => TypedEmitter<CamundaJobWorkerEvents>;
export declare class CamundaJobWorker<VariablesDto extends LosslessDto, CustomHeadersDto extends LosslessDto> extends CamundaJobWorker_base {
    private readonly config;
    private readonly restClient;
    currentlyActiveJobCount: number;
    capacity: number;
    private loopHandle?;
    private pollInterval;
    log: Logger;
    logMeta: () => {
        worker: string;
        type: string;
        pollIntervalMs: number;
        capacity: number;
        currentload: number;
    };
    constructor(config: CamundaJobWorkerConfig<VariablesDto, CustomHeadersDto>, restClient: CamundaRestClient);
    start(): void;
    /** Stops the Job Worker polling for more jobs. If await this call, and it will return as soon as all currently active jobs are completed.
     * The deadline for all currently active jobs to complete is 30s by default. If the active jobs do not complete by the deadline, this method will throw.
     */
    stop(deadlineMs?: number): Promise<unknown>;
    private poll;
    private handleJob;
}
export {};
