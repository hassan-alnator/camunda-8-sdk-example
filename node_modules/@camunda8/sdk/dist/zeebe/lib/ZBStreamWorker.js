"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZBStreamWorker = void 0;
const chalk_1 = __importDefault(require("chalk"));
const interfaces_1_0_1 = require("./interfaces-1.0");
const _1 = require(".");
class ZBStreamWorker {
    constructor({ grpcClient, log, zbClient, }) {
        this.streams = [];
        this.grpcClient = grpcClient;
        this.logger = log;
        this.zbClient = zbClient;
        if (!this.zbClient) {
            console.log(`Missing ZBClient`);
        }
    }
    streamJobs(req) {
        const { taskHandler, inputVariableDto, customHeadersDto, ...streamReq } = req;
        return this.grpcClient
            .streamActivatedJobsStream(streamReq)
            .then((stream) => {
            stream.on('error', (e) => {
                console.error(e);
            });
            stream.on('data', (res) => {
                (0, _1.parseVariablesAndCustomHeadersToJSON)(res, inputVariableDto, customHeadersDto)
                    .then((job) => {
                    taskHandler({
                        ...job,
                        // eslint-disable-next-line @typescript-eslint/no-explicit-any
                        ...this.makeCompleteHandlers(job, req.type),
                    }, this);
                })
                    .catch((e) => this.zbClient.failJob({
                    jobKey: res.key,
                    errorMessage: `Error parsing variable payload ${e}`,
                    retries: res.retries - 1,
                    retryBackOff: 0,
                }));
            });
            this.streams.push(stream);
            return {
                close: () => {
                    stream.removeAllListeners();
                    stream.cancel();
                    stream.destroy();
                },
            };
        });
    }
    close() {
        this.streams.forEach((s) => {
            s.removeAllListeners();
            s.cancel();
            s.destroy();
        });
        return this.grpcClient.close();
    }
    log(msg) {
        this.logger.logInfo(msg);
    }
    debug(msg) {
        this.logger.logDebug(msg);
    }
    error(msg) {
        this.logger.logError(msg);
    }
    makeCompleteHandlers(thisJob, taskType) {
        let methodCalled;
        /**
         * This is a wrapper that allows us to throw an error if a job acknowledgement function is called more than once,
         * for these functions should be called once only (and only one should be called, but we don't handle that case).
         */
        const errorMsgOnPriorMessageCall = (thisMethod, wrappedFunction) => {
            return (...args) => {
                if (methodCalled !== undefined) {
                    // tslint:disable-next-line: no-console
                    console.log(chalk_1.default.red(`WARNING: Call to ${thisMethod}() after ${methodCalled}() was called.
You should call only one job action method in the worker handler. This is a bug in a Stream worker handler.`));
                    return wrappedFunction(...args);
                }
                methodCalled = thisMethod;
                return wrappedFunction(...args);
            };
        };
        const cancelWorkflow = (job) => () => this.zbClient
            .cancelProcessInstance(job.processInstanceKey)
            .then(() => interfaces_1_0_1.JOB_ACTION_ACKNOWLEDGEMENT);
        const failJob = (job) => (conf, retries) => {
            const isFailureConfig = (_conf) => typeof _conf === 'object';
            const errorMessage = isFailureConfig(conf) ? conf.errorMessage : conf;
            const retryBackOff = isFailureConfig(conf) ? conf.retryBackOff ?? 0 : 0;
            const _retries = isFailureConfig(conf) ? conf.retries ?? 0 : retries;
            return this.failJob({
                job,
                errorMessage,
                retries: _retries,
                retryBackOff,
            });
        };
        const succeedJob = (job) => (completedVariables) => this.completeJob(job.key, completedVariables ?? {}, taskType);
        const errorJob = (job) => (e, errorMessage = '') => {
            const isErrorJobWithVariables = (s) => typeof s === 'object';
            const errorCode = isErrorJobWithVariables(e) ? e.errorCode : e;
            errorMessage = isErrorJobWithVariables(e)
                ? e.errorMessage ?? ''
                : errorMessage;
            const variables = isErrorJobWithVariables(e) ? e.variables : {};
            return this.errorJob({
                errorCode,
                errorMessage,
                job,
                variables,
            });
        };
        const fail = failJob(thisJob);
        const succeed = succeedJob(thisJob);
        return {
            cancelWorkflow: cancelWorkflow(thisJob),
            complete: errorMsgOnPriorMessageCall('job.complete', succeed),
            error: errorMsgOnPriorMessageCall('error', errorJob(thisJob)),
            fail: errorMsgOnPriorMessageCall('job.fail', fail),
            forward: errorMsgOnPriorMessageCall('job.forward', () => {
                return interfaces_1_0_1.JOB_ACTION_ACKNOWLEDGEMENT;
            }),
        };
    }
    failJob({ job, errorMessage, retries, retryBackOff, }) {
        return this.zbClient
            .failJob({
            errorMessage,
            jobKey: job.key,
            retries: retries ?? job.retries - 1,
            retryBackOff: retryBackOff ?? 0,
        })
            .then(() => interfaces_1_0_1.JOB_ACTION_ACKNOWLEDGEMENT)
            .finally(() => {
            this.logger.logDebug(`Failed job ${job.key} - ${errorMessage}`);
        });
    }
    completeJob(jobKey, completedVariables = {}, taskType) {
        return this.zbClient
            .completeJob({
            jobKey,
            variables: completedVariables,
        })
            .then((res) => {
            this.logger.logDebug(`Completed job ${jobKey} for ${taskType}`);
            return res;
        })
            .catch((e) => {
            this.logger.logDebug(`Completing job ${jobKey} for ${taskType} threw ${e.message}`);
            return e;
        })
            .then(() => interfaces_1_0_1.JOB_ACTION_ACKNOWLEDGEMENT);
    }
    errorJob({ errorCode, errorMessage, job, variables, }) {
        return this.zbClient
            .throwError({
            errorCode,
            errorMessage,
            jobKey: job.key,
            variables,
        })
            .then(() => this.logger.logDebug(`Errored job ${job.key} - ${errorMessage}`))
            .catch((e) => {
            this.logger.logError(`Exception while attempting to raise BPMN Error for job ${job.key} - ${errorMessage}`);
            this.logger.logError(e);
        })
            .then(() => {
            return interfaces_1_0_1.JOB_ACTION_ACKNOWLEDGEMENT;
        });
    }
}
exports.ZBStreamWorker = ZBStreamWorker;
//# sourceMappingURL=ZBStreamWorker.js.map